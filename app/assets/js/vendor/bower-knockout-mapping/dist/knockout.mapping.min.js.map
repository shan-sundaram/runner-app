{"version":3,"sources":["knockout.mapping.min.js"],"names":["factory","require","exports","module","define","ko","Error","mapping","unionArrays","i","j","k","args","arguments","l","length","obj","res","push","extendObject","destination","source","destType","key","hasOwnProperty","getType","bothArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","recognizedRootProperties","property","Object","ignore","mergeArrays","include","copy","observe","defaultOptions","mappedProperties","copiedProperties","a","b","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","dependentObservables","callback","localDO","dependentObservable","read","owner","realDeferEvaluation","deferEvaluation","isRemoved","wrap","DO","tmp","realKoDependentObservable","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","write","val","__DO","realDependentObservable","fn","computed","result","updateViewModel","mappedRootObject","rootObject","parentName","parent","parentPropertyName","mappedParent","isArray","unwrapObservable","isMapped","previousMapping","mappingProperty","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","emptyReturn","hasUpdateCallback","update","updateCallback","params","target","observable","alreadyMapped","visitedObjects","get","changes","hasKeyCallback","keyCallback","x","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","value","remove","item","mappedRemoveAll","arrayOfValues","arrayOfKeys","filterArrayByKey","arrayIndexOf","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","keys","mappedGet","mappedCreate","newValue","currentArrayKeys","sort","newArrayKeys","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","undefined","index","newContents","passedOver","mappedItem","fullPropertyName","status","getItemByKey","ignorableIndexOf","event","arrayChanged","arrayForEach","change","canHaveProperties","save","visitPropertiesOrArrayEntries","indexer","prevMappedProperty","retval","valueToWrite","hasCreateOrUpdateCallback","array","ignoreIndices","mapKey","arrayMap","visitorCallback","propertyName","object","type","getPropertyName","SimpleObjectLookup","values","this","existingIndex","ObjectLookup","buckets","findBucket","bucketKey","e","bucket","mappingNesting","_defaultOptions","viewModel","unwrapped","fromJS","jsObject","pop","fromJSON","jsonString","prototype","slice","call","parseJson","toJS","resetDefaultOptions","visitModel","toJSON","plainJavaScriptObject","stringifyJson","constructor","Date","propertyValue","previouslyMappedValue"],"mappings":"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","file":"knockout.mapping.min.js","sourcesContent":["/*!\n * Knockout Mapping plugin v2.5.0\n * (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n(function(factory) {\n    'use strict';\n\n    /*jshint sub:true,curly:false*/\n    /*global ko,require,exports,define,module*/\n\n    if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n        // CommonJS or Node: hard-coded dependency on \"knockout\"\n        factory(require(\"knockout\"), exports);\n    }\n    else if (typeof define === \"function\" && define[\"amd\"]) {\n        // AMD anonymous module with hard-coded dependency on \"knockout\"\n        define([\"knockout\", \"exports\"], factory);\n    }\n    else {\n        // <script> tag: use the global `ko` object, attaching a `mapping` property\n        if (typeof ko === 'undefined') {\n            throw new Error('Knockout is required, please ensure it is loaded before loading this mapping plug-in');\n        }\n        factory(ko, ko.mapping = {});\n    }\n}(function(ko, exports) {\n    /*jshint sub:true,curly:false*/\n    'use strict';\n\n    ko.mapping = exports;\n\n    const DEBUG=false;\n    var mappingProperty = \"__ko_mapping__\";\n    var realKoDependentObservable = ko.dependentObservable;\n    var mappingNesting = 0;\n    var dependentObservables;\n    var visitedObjects;\n    var recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n    var emptyReturn = {};\n\n    var _defaultOptions = {\n        include: [\"_destroy\"],\n        ignore: [],\n        copy: [],\n        observe: []\n    };\n    var defaultOptions = _defaultOptions;\n\n    function unionArrays() {\n        var args = arguments,\n            l = args.length,\n            obj = {},\n            res = [],\n            i, j, k;\n\n        while (l--) {\n            k = args[l];\n            i = k.length;\n\n            while (i--) {\n                j = k[i];\n                if (!obj[j]) {\n                    obj[j] = 1;\n                    res.push(j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function extendObject(destination, source) {\n        var destType;\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && source[key]) {\n                destType = exports.getType(destination[key]);\n                if (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n                    extendObject(destination[key], source[key]);\n                }\n                else {\n                    var bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n                    if (bothArrays) {\n                        destination[key] = unionArrays(destination[key], source[key]);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n        }\n    }\n\n    function merge(obj1, obj2) {\n        var merged = {};\n        extendObject(merged, obj1);\n        extendObject(merged, obj2);\n\n        return merged;\n    }\n\n    exports.isMapped = function(viewModel) {\n        var unwrapped = ko.utils.unwrapObservable(viewModel);\n        return unwrapped && unwrapped[mappingProperty];\n    };\n\n    exports.fromJS = function(jsObject /*, inputOptions, target*/) {\n        if (arguments.length === 0) {\n            throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n        }\n        try {\n            if (!mappingNesting) {\n                dependentObservables = [];\n                visitedObjects = new ObjectLookup();\n            }\n            mappingNesting++;\n\n            var options;\n            var target;\n\n            if (arguments.length === 2) {\n                if (arguments[1][mappingProperty]) {\n                    target = arguments[1];\n                }\n                else {\n                    options = arguments[1];\n                }\n            }\n            if (arguments.length === 3) {\n                options = arguments[1];\n                target = arguments[2];\n            }\n\n            if (target) {\n                options = merge(options, target[mappingProperty]);\n            }\n            options = fillOptions(options);\n\n            var result = updateViewModel(target, jsObject, options);\n            if (target) {\n                result = target;\n            }\n\n            // Evaluate any dependent observables that were proxied.\n            // Do this after the model's observables have been created\n            if (!--mappingNesting) {\n                while (dependentObservables.length) {\n                    var DO = dependentObservables.pop();\n                    if (DO) {\n                        DO();\n                        // Move this magic property to the underlying dependent observable\n                        DO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n                    }\n                }\n            }\n\n            // Save any new mapping options in the view model, so that updateFromJS can use them later.\n            result[mappingProperty] = merge(result[mappingProperty], options);\n\n            return result;\n        }\n        catch (e) {\n            mappingNesting = 0;\n            throw e;\n        }\n    };\n\n    exports.fromJSON = function(jsonString /*, options, target*/) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args[0] = ko.utils.parseJson(jsonString);\n        return exports.fromJS.apply(this, args);\n    };\n\n    exports.toJS = function(rootObject, options) {\n        if (!defaultOptions) exports.resetDefaultOptions();\n\n        if (arguments.length === 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n        if (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n        if (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n        if (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n        // Merge in the options used in fromJS\n        options = fillOptions(options, rootObject[mappingProperty]);\n\n        // We just unwrap everything at every level in the object graph\n        return exports.visitModel(rootObject, function(x) {\n            return ko.utils.unwrapObservable(x);\n        }, options);\n    };\n\n    exports.toJSON = function(rootObject, options) {\n        var plainJavaScriptObject = exports.toJS(rootObject, options);\n        return ko.utils.stringifyJson(plainJavaScriptObject);\n    };\n\n    exports.defaultOptions = function() {\n        if (arguments.length > 0) {\n            defaultOptions = arguments[0];\n        }\n        else {\n            return defaultOptions;\n        }\n    };\n\n    exports.resetDefaultOptions = function() {\n        defaultOptions = {\n            include: _defaultOptions.include.slice(0),\n            ignore: _defaultOptions.ignore.slice(0),\n            copy: _defaultOptions.copy.slice(0),\n            observe: _defaultOptions.observe.slice(0)\n        };\n    };\n\n    exports.getType = function(x) {\n        if ((x) && (typeof (x) === \"object\")) {\n            if (x.constructor === Date) return \"date\";\n            if (x.constructor === Array) return \"array\";\n        }\n        return typeof x;\n    };\n\n    function fillOptions(rawOptions, otherOptions) {\n        var options = merge({}, rawOptions);\n\n        // Move recognized root-level properties into a root namespace\n        for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n            var property = recognizedRootProperties[i];\n\n            // Carry on, unless this property is present\n            if (!options[property]) continue;\n\n            // Move the property into the root namespace\n            if (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n            options[\"\"][property] = options[property];\n            delete options[property];\n        }\n\n        if (otherOptions) {\n            options.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n            options.include = mergeArrays(otherOptions.include, options.include);\n            options.copy = mergeArrays(otherOptions.copy, options.copy);\n            options.observe = mergeArrays(otherOptions.observe, options.observe);\n        }\n        options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n        options.include = mergeArrays(options.include, defaultOptions.include);\n        options.copy = mergeArrays(options.copy, defaultOptions.copy);\n        options.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n        options.mappedProperties = options.mappedProperties || {};\n        options.copiedProperties = options.copiedProperties || {};\n        return options;\n    }\n\n    function mergeArrays(a, b) {\n        if (exports.getType(a) !== \"array\") {\n            if (exports.getType(a) === \"undefined\") a = [];\n            else a = [a];\n        }\n        if (exports.getType(b) !== \"array\") {\n            if (exports.getType(b) === \"undefined\") b = [];\n            else b = [b];\n        }\n\n        return ko.utils.arrayGetDistinctValues(a.concat(b));\n    }\n\n    // When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n    // The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n    function withProxyDependentObservable(dependentObservables, callback) {\n        var localDO = ko.dependentObservable;\n        ko.dependentObservable = function(read, owner, options) {\n            options = options || {};\n\n            if (read && typeof read === \"object\") { // mirrors condition in knockout implementation of DO's\n                options = read;\n            }\n\n            var realDeferEvaluation = options.deferEvaluation;\n\n            var isRemoved = false;\n\n            // We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n            // completed if the user already evaluated the DO themselves in the meantime.\n            var wrap = function(DO) {\n                // Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n                var tmp = ko.dependentObservable;\n                ko.dependentObservable = realKoDependentObservable;\n                var isWriteable = ko.isWriteableObservable(DO);\n                ko.dependentObservable = tmp;\n\n                var wrapped = realKoDependentObservable({\n                    read: function() {\n                        if (!isRemoved) {\n                            ko.utils.arrayRemoveItem(dependentObservables, DO);\n                            isRemoved = true;\n                        }\n                        return DO.apply(DO, arguments);\n                    },\n                    write: isWriteable && function(val) {\n                        return DO(val);\n                    },\n                    deferEvaluation: true\n                });\n                if (DEBUG) wrapped._wrapper = true;\n                wrapped.__DO = DO;\n                return wrapped;\n            };\n\n            options.deferEvaluation = true; // will either set for just options, or both read/options.\n            var realDependentObservable = realKoDependentObservable(read, owner, options);\n\n            if (!realDeferEvaluation) {\n                realDependentObservable = wrap(realDependentObservable);\n                dependentObservables.push(realDependentObservable);\n            }\n\n            return realDependentObservable;\n        };\n        ko.dependentObservable.fn = realKoDependentObservable.fn;\n        ko.computed = ko.dependentObservable;\n        var result = callback();\n        ko.dependentObservable = localDO;\n        ko.computed = ko.dependentObservable;\n        return result;\n    }\n\n    function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n        var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n        parentPropertyName = parentPropertyName || \"\";\n\n        // If this object was already mapped previously, take the options from there and merge them with our existing ones.\n        if (exports.isMapped(mappedRootObject)) {\n            var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n            options = merge(previousMapping, options);\n        }\n\n        var callbackParams = {\n            data: rootObject,\n            parent: mappedParent || parent\n        };\n\n        var hasCreateCallback = function() {\n            return options[parentName] && options[parentName].create instanceof Function;\n        };\n\n        var createCallback = function(data) {\n            return withProxyDependentObservable(dependentObservables, function() {\n\n                if (ko.utils.unwrapObservable(parent) instanceof Array) {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent,\n                        skip: emptyReturn\n                    });\n                }\n                else {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent\n                    });\n                }\n            });\n        };\n\n        var hasUpdateCallback = function() {\n            return options[parentName] && options[parentName].update instanceof Function;\n        };\n\n        var updateCallback = function(obj, data) {\n            var params = {\n                data: data || callbackParams.data,\n                parent: callbackParams.parent,\n                target: ko.utils.unwrapObservable(obj)\n            };\n\n            if (ko.isWriteableObservable(obj)) {\n                params.observable = obj;\n            }\n\n            return options[parentName].update(params);\n        };\n\n        var alreadyMapped = visitedObjects.get(rootObject);\n        if (alreadyMapped) {\n            return alreadyMapped;\n        }\n\n        parentName = parentName || \"\";\n\n        if (!isArray) {\n            // For atomic types, do a direct update on the observable\n            if (!canHaveProperties(rootObject)) {\n                switch (exports.getType(rootObject)) {\n                    case \"function\":\n                        if (hasUpdateCallback()) {\n                            if (ko.isWriteableObservable(rootObject)) {\n                                rootObject(updateCallback(rootObject));\n                                mappedRootObject = rootObject;\n                            }\n                            else {\n                                mappedRootObject = updateCallback(rootObject);\n                            }\n                        }\n                        else {\n                            mappedRootObject = rootObject;\n                        }\n                        break;\n                    default:\n                        if (ko.isWriteableObservable(mappedRootObject)) {\n                            var valueToWrite;\n                            if (hasUpdateCallback()) {\n                                valueToWrite = updateCallback(mappedRootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                            else {\n                                valueToWrite = ko.utils.unwrapObservable(rootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                        }\n                        else {\n                            var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\n                            if (hasCreateCallback()) {\n                                mappedRootObject = createCallback();\n                            }\n                            else {\n                                mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n                            }\n\n                            if (hasUpdateCallback()) {\n                                mappedRootObject(updateCallback(mappedRootObject));\n                            }\n\n                            if (hasCreateOrUpdateCallback) return mappedRootObject;\n                        }\n                }\n\n            }\n            else {\n                mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n                if (!mappedRootObject) {\n                    if (hasCreateCallback()) {\n                        var result = createCallback();\n\n                        if (hasUpdateCallback()) {\n                            result = updateCallback(result);\n                        }\n                        return result;\n                    }\n                    else {\n                        if (hasUpdateCallback()) {\n                            //Removed ambiguous parameter result\n                            return updateCallback();\n                        }\n                        mappedRootObject = {};\n                    }\n                }\n\n                if (hasUpdateCallback()) {\n                    mappedRootObject = updateCallback(mappedRootObject);\n                }\n\n                visitedObjects.save(rootObject, mappedRootObject);\n                if (hasUpdateCallback()) return mappedRootObject;\n\n                // For non-atomic types, visit all properties and update recursively\n                visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n                    var fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + indexer : indexer;\n\n                    if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) !== -1) {\n                        return;\n                    }\n\n                    if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) !== -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        return;\n                    }\n\n                    if (typeof rootObject[indexer] !== \"object\" && exports.getType(rootObject[indexer]) !== \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    // In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n                    // If this is a property that was generated by fromJS, we should use the options specified there\n                    var prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n                    var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n                    var value = prevMappedProperty || retval;\n\n                    if (options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = ko.utils.unwrapObservable(value);\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    if (ko.isWriteableObservable(mappedRootObject[indexer])) {\n                        value = ko.utils.unwrapObservable(value);\n                        if (mappedRootObject[indexer]() !== value) {\n                            mappedRootObject[indexer](value);\n                        }\n                    }\n                    else {\n                        value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n                        mappedRootObject[indexer] = value;\n                    }\n\n                    options.mappedProperties[fullPropertyName] = true;\n                });\n            }\n        }\n        else { //mappedRootObject is an array\n            var changes = [];\n\n            var hasKeyCallback = false;\n            var keyCallback = function(x) {\n                return x;\n            };\n            if (options[parentName] && options[parentName].key) {\n                keyCallback = options[parentName].key;\n                hasKeyCallback = true;\n            }\n\n            if (!ko.isObservable(mappedRootObject)) {\n                // When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n                mappedRootObject = ko.observableArray([]);\n\n                mappedRootObject.mappedRemove = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.remove(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedRemoveAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.remove(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedDestroy = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.destroy(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedDestroyAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.destroy(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedIndexOf = function(item) {\n                    var keys = filterArrayByKey(mappedRootObject(), keyCallback);\n                    var key = keyCallback(item);\n                    return ko.utils.arrayIndexOf(keys, key);\n                };\n\n                mappedRootObject.mappedGet = function(item) {\n                    return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n                };\n\n                mappedRootObject.mappedCreate = function(value) {\n                    if (mappedRootObject.mappedIndexOf(value) !== -1) {\n                        throw new Error(\"There already is an object with the key that you specified.\");\n                    }\n                    var item = hasCreateCallback() ? createCallback(value) : value;\n                    if (hasUpdateCallback()) {\n                        var newValue = updateCallback(item, value);\n                        if (ko.isWriteableObservable(item)) {\n                            item(newValue);\n                        }\n                        else {\n                            item = newValue;\n                        }\n                    }\n                    mappedRootObject.push(item);\n                    return item;\n                };\n            }\n\n            var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n            var newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n            if (hasKeyCallback) newArrayKeys.sort();\n            var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n            var ignoreIndexOf = {};\n\n            var i, j, key;\n\n            var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n            var itemsByKey = {};\n            var optimizedKeys = true;\n            for (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n                key = keyCallback(unwrappedRootObject[i]);\n                if (key === undefined || key instanceof Object) {\n                    optimizedKeys = false;\n                    break;\n                }\n                itemsByKey[key] = unwrappedRootObject[i];\n            }\n\n            var newContents = [];\n            var passedOver = 0;\n            var item, index;\n\n            for (i = 0, j = editScript.length; i < j; i++) {\n                key = editScript[i];\n                var mappedItem;\n                var fullPropertyName = parentPropertyName + \"[\" + i + \"]\";\n                switch (key.status) {\n                    case \"added\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n                        if (!hasCreateCallback()) {\n                            mappedItem = ko.utils.unwrapObservable(mappedItem);\n                        }\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\n                        if (mappedItem === emptyReturn) {\n                            passedOver++;\n                        }\n                        else {\n                            newContents[index - passedOver] = mappedItem;\n                        }\n\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"retained\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n                        newContents[index] = mappedItem;\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"deleted\":\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        break;\n                }\n\n                changes.push({\n                    event: key.status,\n                    item: mappedItem\n                });\n            }\n\n            mappedRootObject(newContents);\n\n            if (options[parentName] && options[parentName].arrayChanged) {\n                ko.utils.arrayForEach(changes, function(change) {\n                    options[parentName].arrayChanged(change.event, change.item);\n                });\n            }\n        }\n\n        return mappedRootObject;\n    }\n\n    function ignorableIndexOf(array, item, ignoreIndices) {\n        for (var i = 0, j = array.length; i < j; i++) {\n            if (ignoreIndices[i] === true) continue;\n            if (array[i] === item) return i;\n        }\n        return null;\n    }\n\n    function mapKey(item, callback) {\n        var mappedItem;\n        if (callback) mappedItem = callback(item);\n        if (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n        return ko.utils.unwrapObservable(mappedItem);\n    }\n\n    function getItemByKey(array, key, callback) {\n        array = ko.utils.unwrapObservable(array);\n        for (var i = 0, j = array.length; i < j; i++) {\n            var item = array[i];\n            if (mapKey(item, callback) === key) return item;\n        }\n\n        throw new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n    }\n\n    function filterArrayByKey(array, callback) {\n        return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function(item) {\n            if (callback) {\n                return mapKey(item, callback);\n            }\n            else {\n                return item;\n            }\n        });\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (exports.getType(rootObject) === \"array\") {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n        }\n        else {\n            for (var propertyName in rootObject) {\n                if (rootObject.hasOwnProperty(propertyName)) {\n                    visitorCallback(propertyName);\n                }\n            }\n        }\n    }\n\n    function canHaveProperties(object) {\n        var type = exports.getType(object);\n        return ((type === \"object\") || (type === \"array\")) && (object !== null);\n    }\n\n    // Based on the parentName, this creates a fully classified name of a property\n\n    function getPropertyName(parentName, parent, indexer) {\n        var propertyName = parentName || \"\";\n        if (exports.getType(parent) === \"array\") {\n            if (parentName) {\n                propertyName += \"[\" + indexer + \"]\";\n            }\n        }\n        else {\n            if (parentName) {\n                propertyName += \".\";\n            }\n            propertyName += indexer;\n        }\n        return propertyName;\n    }\n\n    exports.visitModel = function(rootObject, callback, options) {\n        options = options || {};\n        options.visitedObjects = options.visitedObjects || new ObjectLookup();\n\n        var mappedRootObject;\n        var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n        if (!canHaveProperties(unwrappedRootObject)) {\n            return callback(rootObject, options.parentName);\n        }\n        else {\n            options = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n            // Only do a callback, but ignore the results\n            callback(rootObject, options.parentName);\n            mappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n        }\n\n        options.visitedObjects.save(rootObject, mappedRootObject);\n\n        var parentName = options.parentName;\n        visitPropertiesOrArrayEntries(unwrappedRootObject, function(indexer) {\n            if (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) !== -1) return;\n\n            var propertyValue = unwrappedRootObject[indexer];\n            options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n            // If we don't want to explicitly copy the unmapped property...\n            if (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {\n                // ...find out if it's a property we want to explicitly include\n                if (ko.utils.arrayIndexOf(options.include, indexer) === -1) {\n                    // The mapped properties object contains all the properties that were part of the original object.\n                    // If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n                    if (unwrappedRootObject[mappingProperty] &&\n                        unwrappedRootObject[mappingProperty].mappedProperties && !unwrappedRootObject[mappingProperty].mappedProperties[indexer] &&\n                        unwrappedRootObject[mappingProperty].copiedProperties && !unwrappedRootObject[mappingProperty].copiedProperties[indexer] && (exports.getType(unwrappedRootObject) !== \"array\")) {\n                        return;\n                    }\n                }\n            }\n\n            switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n                case \"object\":\n                case \"array\":\n                case \"undefined\":\n                    var previouslyMappedValue = options.visitedObjects.get(propertyValue);\n                    mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n                    break;\n                default:\n                    mappedRootObject[indexer] = callback(propertyValue, options.parentName);\n            }\n        });\n\n        return mappedRootObject;\n    };\n\n    function SimpleObjectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0) values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            var value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n            return value;\n        };\n    }\n\n    function ObjectLookup() {\n        var buckets = {};\n\n        var findBucket = function(key) {\n            var bucketKey;\n            try {\n                bucketKey = key;//JSON.stringify(key);\n            }\n            catch (e) {\n                bucketKey = \"$$$\";\n            }\n\n            var bucket = buckets[bucketKey];\n            if (bucket === undefined) {\n                bucket = new SimpleObjectLookup();\n                buckets[bucketKey] = bucket;\n            }\n            return bucket;\n        };\n\n        this.save = function(key, value) {\n            findBucket(key).save(key, value);\n        };\n        this.get = function(key) {\n            return findBucket(key).get(key);\n        };\n    }\n}));\n"],"sourceRoot":"/source/"}